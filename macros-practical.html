<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Macros, A Practical Introduction - The Little Book of Rust Macros</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="res/code-font-patch.css">
        
        <link rel="stylesheet" href="res/rust-syntax-bg-highlight.css">
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="macros.html"><strong aria-hidden="true">1.</strong> Macros, A Methodical Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="macros/syntax.html"><strong aria-hidden="true">1.1.</strong> Syntax Extensions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="macros/syntax/source-analysys.html"><strong aria-hidden="true">1.1.1.</strong> Source Analysis</a></li><li class="chapter-item expanded "><a href="macros/syntax/ast.html"><strong aria-hidden="true">1.1.2.</strong> Macros in the Ast</a></li><li class="chapter-item expanded "><a href="macros/syntax/expansion.html"><strong aria-hidden="true">1.1.3.</strong> Expansion</a></li></ol></li><li class="chapter-item expanded "><a href="macros/macro_rules.html"><strong aria-hidden="true">1.2.</strong> macro_rules!</a></li><li class="chapter-item expanded "><a href="macros/minutiae.html"><strong aria-hidden="true">1.3.</strong> Minutiae</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="macros/minutiae/metavar-and-expansion.html"><strong aria-hidden="true">1.3.1.</strong> Metavariables and Expansion Redux</a></li><li class="chapter-item expanded "><a href="macros/minutiae/hygiene.html"><strong aria-hidden="true">1.3.2.</strong> Hygiene</a></li><li class="chapter-item expanded "><a href="macros/minutiae/identifiers.html"><strong aria-hidden="true">1.3.3.</strong> Non-Identifier Identifiers</a></li><li class="chapter-item expanded "><a href="macros/minutiae/debugging.html"><strong aria-hidden="true">1.3.4.</strong> Debugging</a></li><li class="chapter-item expanded "><a href="macros/minutiae/scoping.html"><strong aria-hidden="true">1.3.5.</strong> Scoping</a></li><li class="chapter-item expanded "><a href="macros/minutiae/import-export.html"><strong aria-hidden="true">1.3.6.</strong> Import and Export</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="macros-practical.html" class="active"><strong aria-hidden="true">2.</strong> Macros, A Practical Introduction</a></li><li class="chapter-item expanded "><a href="patterns.html"><strong aria-hidden="true">3.</strong> Patterns</a></li><li class="chapter-item expanded "><a href="building-blocks.html"><strong aria-hidden="true">4.</strong> Building Blocks</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="building-blocks/ast-coercion.html"><strong aria-hidden="true">4.1.</strong> AST Coercion</a></li><li class="chapter-item expanded "><a href="building-blocks/counting.html"><strong aria-hidden="true">4.2.</strong> Counting</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The Little Book of Rust Macros</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/veykril/tlborm/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#macros-a-practical-introduction" id="macros-a-practical-introduction">Macros, A Practical Introduction</a></h1>
<p>This chapter will introduce the Rust macro-by-example system using a relatively simple, practical
example. It does <em>not</em> attempt to explain all of the intricacies of the system; its goal is to get
you comfortable with how and why macros are written.</p>
<p>There is also the <a href="https://doc.rust-lang.org/book/ch19-06-macros.html">Macros chapter of the Rust Book</a>
which is another high-level explanation, and the <a href="./macros.html">methodical introduction</a> chapter of
this book, which explains the macro system in detail.</p>
<h2><a class="header" href="#a-little-context" id="a-little-context">A Little Context</a></h2>
<blockquote>
<p><strong>Note</strong>: don't panic! What follows is the only math that will be talked about. You can quite
safely skip this section if you just want to get to the meat of the article.</p>
</blockquote>
<p>If you aren't familiar, a recurrence relation is a sequence where each value is defined in terms of
one or more <em>previous</em> values, with one or more initial values to get the whole thing started. For
example, the <a href="https://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci sequence</a> can be defined by
the relation:</p>
<p>\[ F_{n} = 0, 1, ..., F_{m-1} + F_{n-2}\]</p>
<p>Thus, the first two numbers in the sequence are 0 and 1, with the third being 
\( F_{0} + F_{1} = 0 + 1 = 1\), the fourth \( F_{1} + F_{2} = 1 + 1 = 2\), and so on forever.</p>
<p>Now, <em>because</em> such a sequence can go on forever, that makes defining a <code>fibonacci</code> function a
little tricky, since you obviously don't want to try returning a complete vector. What you <em>want</em> is
to return something which will lazily compute elements of the sequence as needed.</p>
<p>In Rust, that means producing an <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code></a>. This is not especially <em>hard</em>, but there is a fair
amount of boilerplate involved: you need to define a custom type, work out what state needs to be
stored in it, then implement the <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code></a> trait for it.</p>
<p>However, recurrence relations are simple enough that almost all of these details can be abstracted
out with a little macro-based code generation.</p>
<p>So, with all that having been said, let's get started.</p>
<h2><a class="header" href="#construction" id="construction">Construction</a></h2>
<p>Usually, when working on a new macro, the first thing I do is decide what the macro invocation
should look like. In this specific case, my first attempt looked like this:</p>
<pre><code class="language-rust ignore">let fib = recurrence![a[n] = 0, 1, ..., a[n-1] + a[n-2]];

for e in fib.take(10) { println!(&quot;{}&quot;, e) }
</code></pre>
<p>From that, we can take a stab at how the macro should be defined, even if we aren't sure of the
actual expansion. This is useful because if you can't figure out how to parse the input syntax, then
<em>maybe</em> you need to change it.</p>
<pre><code class="language-rust ignore">macro_rules! recurrence {
    ( a[n] = $($inits:expr),+ , ... , $recur:expr ) =&gt; { /* ... */ };
}
<span class="boring">fn main() {}
</span></code></pre>
<p>Assuming you aren't familiar with the syntax, allow me to elucidate. This is defining a macro, using
the <a href="./macros/macro_rules.html"><code>macro_rules!</code></a> system, called <code>recurrence!</code>. This macro has a single parsing rule. That rule
says the input to the macro must match:</p>
<ul>
<li>the literal token sequence <code>a</code> <code>[</code> <code>n</code> <code>]</code> <code>=</code>,</li>
<li>a <a href="./macros/macro_rules.html#repetitions">repeating</a> (the <code>$( ... )</code>) sequence, using <code>,</code> as a separator, and one or more (<code>+</code>) repeats of:
<ul>
<li>a valid <em>expression</em> captured into the <a href="./macros/macro_rules.html#metavariables">metavariable</a> <code>inits</code> (<code>$inits:expr</code>)</li>
</ul>
</li>
<li>the literal token sequence <code>,</code> <code>...</code> <code>,</code>,</li>
<li>a valid <em>expression</em> captured into the <a href="./macros/macro_rules.html#metavariables">metavariable</a> <code>recur</code> (<code>$recur:expr</code>).</li>
</ul>
<p>Finally, the rule says that <em>if</em> the input matches this rule, then the macro invocation should be
replaced by the token sequence <code>/* ... */</code>.</p>
<p>It's worth noting that <code>inits</code>, as implied by the name, actually contains <em>all</em> the expressions that
match in this position, not just the first or last. What's more, it captures them <em>as a sequence</em> as
opposed to, say, irreversibly pasting them all together. Also note that you can do &quot;zero or more&quot;
with a repetition by using <code>*</code> instead of <code>+</code> and even optional, &quot;zero or one&quot; with <code>?</code>. There is no
support for &quot;zero or one&quot; or more specific numbers of repetitions.</p>
<p>As an exercise, let's take the proposed input and feed it through the rule, to see how it is
processed. The &quot;Position&quot; column will show which part of the syntax pattern needs to be matched
against next, denoted by a &quot;⌂&quot;. Note that in some cases, there might be more than one possible
&quot;next&quot; element to match against. &quot;Input&quot; will contain all of the tokens that have <em>not</em> been
consumed yet. <code>inits</code> and <code>recur</code> will contain the contents of those bindings.</p>
<style type="text/css">
    /* Customisations. */

    .small-code code {
        font-size: 70%;
    }

    table.parse-table code {
        white-space: pre-wrap;
        background-color: transparent;
        border: none;
    }

    table.parse-table tbody>tr>td:nth-child(1)>code:nth-of-type(2) {
        color: red;
        margin-top: -0.7em;
        margin-bottom: -0.6em;
    }

    table.parse-table tbody>tr>td:nth-child(1)>code {
        display: block;
    }

    table.parse-table tbody>tr>td:nth-child(2)>code {
        display: block;
    }
</style>
<table class="parse-table">
    <colgroup>
        <col width="42%" />
        <col width="36%" />
        <col width="0%" />
        <col width="12%" />
    </colgroup>
    <thead>
        <tr>
            <th>Position</th>
            <th>Input</th>
            <th><code>inits</code></th>
            <th><code>recur</code></th>
        </tr>
    </thead>
    <tbody class="small-code">
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>⌂</code></td>
            <td><code>a[n] = 0, 1, ..., a[n-1] + a[n-2]</code></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code> ⌂</code></td>
            <td><code>[n] = 0, 1, ..., a[n-1] + a[n-2]</code></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>  ⌂</code></td>
            <td><code>n] = 0, 1, ..., a[n-1] + a[n-2]</code></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>   ⌂</code></td>
            <td><code>] = 0, 1, ..., a[n-1] + a[n-2]</code></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>     ⌂</code></td>
            <td><code>= 0, 1, ..., a[n-1] + a[n-2]</code></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>       ⌂</code></td>
            <td><code>0, 1, ..., a[n-1] + a[n-2]</code></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>         ⌂</code></td>
            <td><code>0, 1, ..., a[n-1] + a[n-2]</code></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>                     ⌂  ⌂</code></td>
            <td><code>, 1, ..., a[n-1] + a[n-2]</code></td>
            <td><code>0</code></td>
            <td></td>
        </tr>
        <tr>
            <td colspan="4" style="font-size:.8em;">
                <em>Note</em>: there are two ⌂ here, because the next input token might match <em>either</em> the comma
                separator <em>between</em>em> elements in the repetition, <em>or</em> the comma <em>after</em> the
                repetition. The macro system will keep track of both possibilities, until it is able to decide which one
                to follow.
            </td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>         ⌂                ⌂</code></td>
            <td><code>1, ..., a[n-1] + a[n-2]</code></td>
            <td><code>0</code></td>
            <td></td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>                     ⌂  ⌂ <s>⌂</s></code></td>
            <td><code>, ..., a[n-1] + a[n-2]</code></td>
            <td><code>0</code>, <code>1</code></td>
            <td></td>
        </tr>
        <tr>
            <td colspan="4" style="font-size:.8em;">
                <em>Note</em>: the third, crossed-out marker indicates that the macro system has, as a consequence of
                the last token consumed, eliminated one of the previous possible branches.
            </td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>         ⌂                ⌂</code></td>
            <td><code>..., a[n-1] + a[n-2]</code></td>
            <td><code>0</code>, <code>1</code></td>
            <td></td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>         <s>⌂</s>                    ⌂</code></td>
            <td><code>, a[n-1] + a[n-2]</code></td>
            <td><code>0</code>, <code>1</code></td>
            <td></td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>                                ⌂</code></td>
            <td><code>a[n-1] + a[n-2]</code></td>
            <td><code>0</code>, <code>1</code></td>
            <td></td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>                                           ⌂</code></td>
            <td></td>
            <td><code>0</code>, <code>1</code></td>
            <td><code>a[n-1] + a[n-2]</code></td>
        </tr>
        <tr>
            <td colspan="4" style="font-size:.8em;">
                <em>Note</em>: this particular step should make it clear that a binding like <tt>$recur:expr</tt> will
                consume an <em>entire expression</em>, using the compiler's knowledge of what constitutes a valid
                expression. As will be noted later, you can do this for other language constructs, too.
            </td>
        </tr>
    </tbody>
</table>
<p>The key take-away from this is that the macro system will <em>try</em> to incrementally match the tokens
provided as input to the macro against the provided rules. We'll come back to the &quot;try&quot; part.</p>
<p>Now, let's begin writing the final, fully expanded form. For this expansion, I was looking for
something like:</p>
<pre><code class="language-rust ignore">let fib = {
    struct Recurrence {
        mem: [u64; 2],
        pos: usize,
    }
</code></pre>
<p>This will be the actual iterator type. <code>mem</code> will be the memo buffer to hold the last few values so
the recurrence can be computed. <code>pos</code> is to keep track of the value of <code>n</code>.</p>
<blockquote>
<p><strong>Aside</strong>: I've chosen <code>u64</code> as a &quot;sufficiently large&quot; type for the elements of this sequence.
Don't worry about how this will work out for <em>other</em> sequences; we'll come to it.</p>
</blockquote>
<pre><code class="language-rust ignore">    impl Iterator for Recurrence {
        type Item = u64;

        #[inline]
        fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
            if self.pos &lt; 2 {
                let next_val = self.mem[self.pos];
                self.pos += 1;
                Some(next_val)
</code></pre>
<p>We need a branch to yield the initial values of the sequence; nothing tricky.</p>
<pre><code class="language-rust ignore">            } else {
                let a = /* something */;
                let n = self.pos;
                let next_val = a[n-1] + a[n-2];

                self.mem.TODO_shuffle_down_and_append(next_val);

                self.pos += 1;
                Some(next_val)
            }
        }
    }
</code></pre>
<p>This is a bit harder; we'll come back and look at <em>how</em> exactly to define <code>a</code>. Also,
<code>TODO_shuffle_down_and_append</code> is another placeholder; I want something that places <code>next_val</code> on
the end of the array, shuffling the rest down by one space, dropping the 0th element.</p>
<pre><code class="language-rust ignore">
    Recurrence { mem: [0, 1], pos: 0 }
};

for e in fib.take(10) { println!(&quot;{}&quot;, e) }
</code></pre>
<p>Lastly, return an instance of our new structure, which can then be iterated over. To summarise, the
complete expansion is:</p>
<pre><code class="language-rust ignore">let fib = {
    struct Recurrence {
        mem: [u64; 2],
        pos: usize,
    }

    impl Iterator for Recurrence {
        type Item = u64;

        #[inline]
        fn next(&amp;mut self) -&gt; Option&lt;u64&gt; {
            if self.pos &lt; 2 {
                let next_val = self.mem[self.pos];
                self.pos += 1;
                Some(next_val)
            } else {
                let a = /* something */;
                let n = self.pos;
                let next_val = (a[n-1] + a[n-2]);

                self.mem.TODO_shuffle_down_and_append(next_val.clone());

                self.pos += 1;
                Some(next_val)
            }
        }
    }

    Recurrence { mem: [0, 1], pos: 0 }
};

for e in fib.take(10) { println!(&quot;{}&quot;, e) }
</code></pre>
<blockquote>
<p><strong>Aside</strong>: Yes, this <em>does</em> mean we're defining a different <code>Recurrence</code> struct and its
implementation for each macro invocation. Most of this will optimise away in the final binary,
with some judicious use of <code>#[inline]</code> attributes.</p>
</blockquote>
<p>It's also useful to check your expansion as you're writing it. If you see anything in the expansion
that needs to vary with the invocation, but <em>isn't</em> in the actual macro syntax, you should work out
where to introduce it. In this case, we've added <code>u64</code>, but that's not neccesarily what the user
wants, nor is it in the macro syntax. So let's fix that.</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! recurrence {
    ( a[n]: $sty:ty = $($inits:expr),+ , ... , $recur:expr ) =&gt; { /* ... */ };
}

/*
let fib = recurrence![a[n]: u64 = 0, 1, ..., a[n-1] + a[n-2]];

for e in fib.take(10) { println!(&quot;{}&quot;, e) }
*/
<span class="boring">fn main() {}
</span></code></pre></pre>
<p>Here, I've added a new metavariable: <code>sty</code> which should be a type.</p>
<blockquote>
<p><strong>Aside</strong>: if you're wondering, the bit after the colon in a metavariable can be one of several
kinds of syntax matchers. The most common ones are <code>item</code>, <code>expr</code>, and <code>ty</code>. A complete
explanation can be found in <a href="./macros/macro_rules.html#Metavariables">Macros, A Methodical Introduction; <code>macro_rules!</code> (Matchers)</a>.</p>
<p>There's one other thing to be aware of: in the interests of future-proofing the language, the
compiler restricts what tokens you're allowed to put <em>after</em> a matcher, depending on what kind
it is. Typically, this comes up when trying to match expressions or statements; those can
<em>only</em> be followed by one of <code>=&gt;</code>, <code>,</code>, and <code>;</code>.</p>
<p>A complete list can be found in
<a href="./macros/minutiae/metavar-and-expansion.html">Macros, A Methodical Introduction; Minutiae; Metavariables and Expansion Redux</a>.</p>
</blockquote>
<h2><a class="header" href="#indexing-and-shuffling" id="indexing-and-shuffling">Indexing and Shuffling</a></h2>
<p>I will skim a bit over this part, since it's effectively tangential to the macro stuff. We want to
make it so that the user can access previous values in the sequence by indexing <code>a</code>; we want it to
act as a sliding window keeping the last few (in this case, 2) elements of the sequence.</p>
<p>We can do this pretty easily with a wrapper type:</p>
<pre><code class="language-rust ignore">struct IndexOffset&lt;'a&gt; {
    slice: &amp;'a [u64; 2],
    offset: usize,
}

impl&lt;'a&gt; Index&lt;usize&gt; for IndexOffset&lt;'a&gt; {
    type Output = u64;

    #[inline(always)]
    fn index&lt;'b&gt;(&amp;'b self, index: usize) -&gt; &amp;'b u64 {
        use std::num::Wrapping;

        let index = Wrapping(index);
        let offset = Wrapping(self.offset);
        let window = Wrapping(2);

        let real_index = index - offset + window;
        &amp;self.slice[real_index.0]
    }
}
</code></pre>
<blockquote>
<p><strong>Aside</strong>: since lifetimes come up <em>a lot</em> with people new to Rust, a quick explanation: <code>'a</code> and
<code>'b</code> are lifetime parameters that are used to track where a reference
(<em>i.e.</em> a borrowed pointer to some data) is valid. In this case, <code>IndexOffset</code> borrows a
reference to our iterator's data, so it needs to keep track of how long it's allowed to hold
that reference for, using <code>'a</code>.</p>
<p><code>'b</code> is used because the <code>Index::index</code> function (which is how subscript syntax is actually
implemented) is <em>also</em> parameterised on a lifetime, on account of returning a borrowed reference.
<code>'a</code> and <code>'b</code> are not necessarily the same thing in all cases. The borrow checker will make sure
that even though we don't explicitly relate <code>'a</code> and <code>'b</code> to one another, we don't accidentally
violate memory safety.</p>
</blockquote>
<p>This changes the definition of <code>a</code> to:</p>
<pre><code class="language-rust ignore">let a = IndexOffset { slice: &amp;self.mem, offset: n };
</code></pre>
<p>The only remaining question is what to do about <code>TODO_shuffle_down_and_append</code>. I wasn't able to
find a method in the standard library with exactly the semantics I wanted, but it isn't hard to do
by hand.</p>
<pre><code class="language-rust ignore">{
    use std::mem::swap;

    let mut swap_tmp = next_val;
    for i in (0..2).rev() {
        swap(&amp;mut swap_tmp, &amp;mut self.mem[i]);
    }
}
</code></pre>
<p>This swaps the new value into the end of the array, swapping the other elements down one space.</p>
<blockquote>
<p><strong>Aside</strong>: doing it this way means that this code will work for non-copyable types, as well.</p>
</blockquote>
<p>The working code thus far now looks like this:</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! recurrence {
    ( a[n]: $sty:ty = $($inits:expr),+ , ... , $recur:expr ) =&gt; { /* ... */ };
}

fn main() {
    /*
    let fib = recurrence![a[n]: u64 = 0, 1, ..., a[n-1] + a[n-2]];

    for e in fib.take(10) { println!(&quot;{}&quot;, e) }
    */
    let fib = {
        use std::ops::Index;

        struct Recurrence {
            mem: [u64; 2],
            pos: usize,
        }

        struct IndexOffset&lt;'a&gt; {
            slice: &amp;'a [u64; 2],
            offset: usize,
        }

        impl&lt;'a&gt; Index&lt;usize&gt; for IndexOffset&lt;'a&gt; {
            type Output = u64;

            #[inline(always)]
            fn index&lt;'b&gt;(&amp;'b self, index: usize) -&gt; &amp;'b u64 {
                use std::num::Wrapping;

                let index = Wrapping(index);
                let offset = Wrapping(self.offset);
                let window = Wrapping(2);

                let real_index = index - offset + window;
                &amp;self.slice[real_index.0]
            }
        }

        impl Iterator for Recurrence {
            type Item = u64;

            #[inline]
            fn next(&amp;mut self) -&gt; Option&lt;u64&gt; {
                if self.pos &lt; 2 {
                    let next_val = self.mem[self.pos];
                    self.pos += 1;
                    Some(next_val)
                } else {
                    let next_val = {
                        let n = self.pos;
                        let a = IndexOffset { slice: &amp;self.mem, offset: n };
                        (a[n-1] + a[n-2])
                    };

                    {
                        use std::mem::swap;

                        let mut swap_tmp = next_val;
                        for i in (0..2).rev() {
                            swap(&amp;mut swap_tmp, &amp;mut self.mem[i]);
                        }
                    }

                    self.pos += 1;
                    Some(next_val)
                }
            }
        }

        Recurrence { mem: [0, 1], pos: 0 }
    };

    for e in fib.take(10) { println!(&quot;{}&quot;, e) }
}
</code></pre></pre>
<p>Note that I've changed the order of the declarations of <code>n</code> and <code>a</code>, as well as wrapped them
(along with the recurrence expression) in a block. The reason for the first should be obvious
(<code>n</code> needs to be defined first so I can use it for <code>a</code>). The reason for the second is that the
borrowed reference <code>&amp;self.mem</code> will prevent the swaps later on from happening (you cannot mutate
something that is aliased elsewhere). The block ensures that the <code>&amp;self.mem</code> borrow expires before
then.</p>
<p>Incidentally, the only reason the code that does the <code>mem</code> swaps is in a block is to narrow the
scope in which <code>std::mem::swap</code> is available, for the sake of being tidy.</p>
<p>If we take this code and run it, we get:</p>
<pre><code class="language-text">0
1
2
3
5
8
13
21
34
</code></pre>
<p>Success! Now, let's copy &amp; paste this into the macro expansion, and replace the expanded code with
an invocation. This gives us:</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! recurrence {
    ( a[n]: $sty:ty = $($inits:expr),+ , ... , $recur:expr ) =&gt; {
        {
            /*
                What follows here is *literally* the code from before,
                cut and pasted into a new position. No other changes
                have been made.
            */

            use std::ops::Index;

            struct Recurrence {
                mem: [u64; 2],
                pos: usize,
            }

            struct IndexOffset&lt;'a&gt; {
                slice: &amp;'a [u64; 2],
                offset: usize,
            }

            impl&lt;'a&gt; Index&lt;usize&gt; for IndexOffset&lt;'a&gt; {
                type Output = u64;

                #[inline(always)]
                fn index&lt;'b&gt;(&amp;'b self, index: usize) -&gt; &amp;'b u64 {
                    use std::num::Wrapping;

                    let index = Wrapping(index);
                    let offset = Wrapping(self.offset);
                    let window = Wrapping(2);

                    let real_index = index - offset + window;
                    &amp;self.slice[real_index.0]
                }
            }

            impl Iterator for Recurrence {
                type Item = u64;

                #[inline]
                fn next(&amp;mut self) -&gt; Option&lt;u64&gt; {
                    if self.pos &lt; 2 {
                        let next_val = self.mem[self.pos];
                        self.pos += 1;
                        Some(next_val)
                    } else {
                        let next_val = {
                            let n = self.pos;
                            let a = IndexOffset { slice: &amp;self.mem, offset: n };
                            (a[n-1] + a[n-2])
                        };

                        {
                            use std::mem::swap;

                            let mut swap_tmp = next_val;
                            for i in (0..2).rev() {
                                swap(&amp;mut swap_tmp, &amp;mut self.mem[i]);
                            }
                        }

                        self.pos += 1;
                        Some(next_val)
                    }
                }
            }

            Recurrence { mem: [0, 1], pos: 0 }
        }
    };
}

fn main() {
    let fib = recurrence![a[n]: u64 = 0, 1, ..., a[n-1] + a[n-2]];

    for e in fib.take(10) { println!(&quot;{}&quot;, e) }
}
</code></pre></pre>
<p>Obviously, we aren't <em>using</em> the metavariables yet, but we can change that fairly easily. However,
if we try to compile this, <code>rustc</code> aborts, telling us:</p>
<pre><code class="language-text">error: local ambiguity: multiple parsing options: built-in NTs expr ('inits') or 1 other option.
  --&gt; src/main.rs:75:45
   |
75 |     let fib = recurrence![a[n]: u64 = 0, 1, ..., a[n-1] + a[n-2]];
   |              
</code></pre>
<p>Here, we've run into a limitation of <code>macro_rules</code>. The problem is that second comma. When it sees
it during expansion, <code>macro_rules</code> can't decide if it's supposed to parse <em>another</em> expression for
<code>inits</code>, or <code>...</code>.  Sadly, it isn't quite clever enough to realise that <code>...</code> isn't a valid
expression, so it gives up. Theoretically, this <em>should</em> work as desired, but currently doesn't.</p>
<blockquote>
<p><strong>Aside</strong>: I <em>did</em> fib a little about how our rule would be interpreted by the macro system. In
general, it <em>should</em> work as described, but doesn't in this case. The <code>macro_rules</code> machinery,
as it stands, has its foibles, and its worthwhile remembering that on occasion, you'll need to
contort a little to get it to work.</p>
<p>In this <em>particular</em> case, there are two issues. First, the macro system doesn't know what does
and does not constitute the various grammar elements (<em>e.g.</em> an expression); that's the parser's
job. As such, it doesn't know that <code>...</code> isn't an expression. Secondly, it has no way of trying
to capture a compound grammar element (like an expression) without 100% committing to that
capture.</p>
<p>In other words, it can ask the parser to try and parse some input as an expression, but the parser
will respond to any problems by aborting. The only way the macro system can currently deal with
this is to just try to forbid situations where this could be a problem.</p>
<p>On the bright side, this is a state of affairs that exactly <em>no one</em> is enthusiastic about. The
<code>macro</code> keyword has already been reserved for a more rigorously-defined future macro system.
Until then, needs must.</p>
</blockquote>
<p>Thankfully, the fix is relatively simple: we remove the comma from the syntax. To keep things
balanced, we'll remove <em>both</em> commas around <code>...</code>:</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! recurrence {
    ( a[n]: $sty:ty = $($inits:expr),+ ... $recur:expr ) =&gt; {
//                                     ^~~ changed
        /* ... */
<span class="boring">        // Cheat :D
</span><span class="boring">        (vec![0u64, 1, 2, 3, 5, 8, 13, 21, 34]).into_iter()
</span>    };
}

fn main() {
    let fib = recurrence![a[n]: u64 = 0, 1 ... a[n-1] + a[n-2]];
//                                         ^~~ changed

    for e in fib.take(10) { println!(&quot;{}&quot;, e) }
}
</code></pre></pre>
<p>Success! ... or so I thought. Turns out this is being rejected by the compiler nowadays, while it
was fine back when this was written. The reason for this is that the compiler now recognizes the
<code>...</code> as a token, and as we know we may only use <code>=&gt;</code>, <code>,</code> or <code>;</code> after an expression fragment. So
unfortunately we are now out of luck as our dreamed up syntax will not work out this way, so let us
just choose one that looks the most befitting that we are allowed to use instead, I'd say <code>=&gt;</code> works.</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! recurrence {
    ( a[n]: $sty:ty = $($inits:expr),+ =&gt; $recur:expr ) =&gt; {
//                                     ^~~ changed
        /* ... */
<span class="boring">        // Cheat :D
</span><span class="boring">        (vec![0u64, 1, 2, 3, 5, 8, 13, 21, 34]).into_iter()
</span>    };
}

fn main() {
    let fib = recurrence![a[n]: u64 = 0, 1 =&gt; a[n-1] + a[n-2]];
//                                         ^~~ changed

    for e in fib.take(10) { println!(&quot;{}&quot;, e) }
}
</code></pre></pre>
<p>Success! But for real this time.</p>
<h3><a class="header" href="#substitution" id="substitution">Substitution</a></h3>
<p>Substituting something you've captured in a macro is quite simple; you can insert the contents of a
metavariable <code>$sty:ty</code> by using <code>$sty</code>. So, let's go through and fix the <code>u64</code>s:</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! recurrence {
    ( a[n]: $sty:ty = $($inits:expr),+ =&gt; $recur:expr ) =&gt; {
        {
            use std::ops::Index;

            struct Recurrence {
                mem: [$sty; 2],
//                    ^~~~ changed
                pos: usize,
            }

            struct IndexOffset&lt;'a&gt; {
                slice: &amp;'a [$sty; 2],
//                          ^~~~ changed
                offset: usize,
            }

            impl&lt;'a&gt; Index&lt;usize&gt; for IndexOffset&lt;'a&gt; {
                type Output = $sty;
//                            ^~~~ changed

                #[inline(always)]
                fn index&lt;'b&gt;(&amp;'b self, index: usize) -&gt; &amp;'b $sty {
//                                                          ^~~~ changed
                    use std::num::Wrapping;

                    let index = Wrapping(index);
                    let offset = Wrapping(self.offset);
                    let window = Wrapping(2);

                    let real_index = index - offset + window;
                    &amp;self.slice[real_index.0]
                }
            }

            impl Iterator for Recurrence {
                type Item = $sty;
//                          ^~~~ changed

                #[inline]
                fn next(&amp;mut self) -&gt; Option&lt;$sty&gt; {
//                                           ^~~~ changed
                    /* ... */
<span class="boring">                    if self.pos &lt; 2 {
</span><span class="boring">                        let next_val = self.mem[self.pos];
</span><span class="boring">                        self.pos += 1;
</span><span class="boring">                        Some(next_val)
</span><span class="boring">                    } else {
</span><span class="boring">                        let next_val = {
</span><span class="boring">                            let n = self.pos;
</span><span class="boring">                            let a = IndexOffset { slice: &amp;self.mem, offset: n };
</span><span class="boring">                            (a[n-1] + a[n-2])
</span><span class="boring">                        };
</span><span class="boring">    
</span><span class="boring">                        {
</span><span class="boring">                            use std::mem::swap;
</span><span class="boring">    
</span><span class="boring">                            let mut swap_tmp = next_val;
</span><span class="boring">                            for i in (0..2).rev() {
</span><span class="boring">                                swap(&amp;mut swap_tmp, &amp;mut self.mem[i]);
</span><span class="boring">                            }
</span><span class="boring">                        }
</span><span class="boring">    
</span><span class="boring">                        self.pos += 1;
</span><span class="boring">                        Some(next_val)
</span><span class="boring">                    }
</span>                }
            }

            Recurrence { mem: [1, 1], pos: 0 }
        }
    };
}

fn main() {
    let fib = recurrence![a[n]: u64 = 0, 1 =&gt; a[n-1] + a[n-2]];

    for e in fib.take(10) { println!(&quot;{}&quot;, e) }
}
</code></pre></pre>
<p>Let's tackle a harder one: how to turn <code>inits</code> into both the array literal <code>[0, 1]</code> <em>and</em> the array
type, <code>[$sty; 2]</code>. The first one we can do like so:</p>
<pre><code class="language-ignore">            Recurrence { mem: [$($inits),+], pos: 0 }
//                             ^~~~~~~~~~~ changed
</code></pre>
<p>This effectively does the opposite of the capture: repeat <code>inits</code> one or more times, separating each
with a comma. This expands to the expected sequence of tokens: <code>0, 1</code>.</p>
<p>Somehow turning <code>inits</code> into a literal <code>2</code> is a little trickier. It turns out that there's no direct
way to do this, but we <em>can</em> do it by using a second macro. Let's take this one step at a time.</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! count_exprs {
    /* ??? */
<span class="boring">    () =&gt; {}
</span>}
<span class="boring">fn main() {}
</span></code></pre></pre>
<p>The obvious case is: given zero expressions, you would expect <code>count_exprs</code> to expand to a literal
<code>0</code>.</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! count_exprs {
    () =&gt; (0);
//  ^~~~~~~~~~ added
}
<span class="boring">fn main() {
</span><span class="boring">    const _0: usize = count_exprs!();
</span><span class="boring">    assert_eq!(_0, 0);
</span><span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong>Aside</strong>: You may have noticed I used parentheses here instead of curly braces for the expansion.
<code>macro_rules</code> really doesn't care <em>what</em> you use, so long as it's one of the &quot;matcher&quot; pairs:
<code>( )</code>, <code>{ }</code> or <code>[ ]</code>. In fact, you can switch out the matchers on the macro itself
(<em>i.e.</em> the matchers right after the macro name), the matchers around the syntax rule, and the
matchers around the corresponding expansion.</p>
<p>You can also switch out the matchers used when you <em>invoke</em> a macro, but in a more limited fashion:
a macro invoked as <code>{ ... }</code> or <code>( ... );</code> will <em>always</em> be parsed as an <em>item</em> (<em>i.e.</em> like a
<code>struct</code> or <code>fn</code> declaration).  This is important when using macros in a function body; it helps
disambiguate between &quot;parse like an expression&quot; and &quot;parse like a statement&quot;.</p>
</blockquote>
<p>What if you have <em>one</em> expression? That should be a literal <code>1</code>.</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! count_exprs {
    () =&gt; (0);
    ($e:expr) =&gt; (1);
//  ^~~~~~~~~~~~~~~~~ added
}
<span class="boring">fn main() {
</span><span class="boring">    const _0: usize = count_exprs!();
</span><span class="boring">    const _1: usize = count_exprs!(x);
</span><span class="boring">    assert_eq!(_0, 0);
</span><span class="boring">    assert_eq!(_1, 1);
</span><span class="boring">}
</span></code></pre></pre>
<p>Two?</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! count_exprs {
    () =&gt; (0);
    ($e:expr) =&gt; (1);
    ($e0:expr, $e1:expr) =&gt; (2);
//  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~ added
}
<span class="boring">fn main() {
</span><span class="boring">    const _0: usize = count_exprs!();
</span><span class="boring">    const _1: usize = count_exprs!(x);
</span><span class="boring">    const _2: usize = count_exprs!(x, y);
</span><span class="boring">    assert_eq!(_0, 0);
</span><span class="boring">    assert_eq!(_1, 1);
</span><span class="boring">    assert_eq!(_2, 2);
</span><span class="boring">}
</span></code></pre></pre>
<p>We can &quot;simplify&quot; this a little by re-expressing the case of two expressions recursively.</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! count_exprs {
    () =&gt; (0);
    ($e:expr) =&gt; (1);
    ($e0:expr, $e1:expr) =&gt; (1 + count_exprs!($e1));
//                           ^~~~~~~~~~~~~~~~~~~~~ changed
}
<span class="boring">fn main() {
</span><span class="boring">    const _0: usize = count_exprs!();
</span><span class="boring">    const _1: usize = count_exprs!(x);
</span><span class="boring">    const _2: usize = count_exprs!(x, y);
</span><span class="boring">    assert_eq!(_0, 0);
</span><span class="boring">    assert_eq!(_1, 1);
</span><span class="boring">    assert_eq!(_2, 2);
</span><span class="boring">}
</span></code></pre></pre>
<p>This is fine since Rust can fold <code>1 + 1</code> into a constant value. What if we have three expressions?</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! count_exprs {
    () =&gt; (0);
    ($e:expr) =&gt; (1);
    ($e0:expr, $e1:expr) =&gt; (1 + count_exprs!($e1));
    ($e0:expr, $e1:expr, $e2:expr) =&gt; (1 + count_exprs!($e1, $e2));
//  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ added
}
<span class="boring">fn main() {
</span><span class="boring">    const _0: usize = count_exprs!();
</span><span class="boring">    const _1: usize = count_exprs!(x);
</span><span class="boring">    const _2: usize = count_exprs!(x, y);
</span><span class="boring">    const _3: usize = count_exprs!(x, y, z);
</span><span class="boring">    assert_eq!(_0, 0);
</span><span class="boring">    assert_eq!(_1, 1);
</span><span class="boring">    assert_eq!(_2, 2);
</span><span class="boring">    assert_eq!(_3, 3);
</span><span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong>Aside</strong>: You might be wondering if we could reverse the order of these rules. In this particular
case, <em>yes</em>, but the macro system can sometimes be picky about what it is and is not willing to
recover from. If you ever find yourself with a multi-rule macro that you <em>swear</em> should work,
but gives you errors about unexpected tokens, try changing the order of the rules.</p>
</blockquote>
<p>Hopefully, you can see the pattern here. We can always reduce the list of expressions by matching
one expression, followed by zero or more expressions, expanding that into 1 + a count.</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! count_exprs {
    () =&gt; (0);
    ($head:expr) =&gt; (1);
    ($head:expr, $($tail:expr),*) =&gt; (1 + count_exprs!($($tail),*));
//  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ changed
}
<span class="boring">fn main() {
</span><span class="boring">    const _0: usize = count_exprs!();
</span><span class="boring">    const _1: usize = count_exprs!(x);
</span><span class="boring">    const _2: usize = count_exprs!(x, y);
</span><span class="boring">    const _3: usize = count_exprs!(x, y, z);
</span><span class="boring">    assert_eq!(_0, 0);
</span><span class="boring">    assert_eq!(_1, 1);
</span><span class="boring">    assert_eq!(_2, 2);
</span><span class="boring">    assert_eq!(_3, 3);
</span><span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong><abbr title="Just for this example">JFTE</abbr></strong>: this is not the <em>only</em>, or even the <em>best</em>
way of counting things. You may wish to peruse the <a href=".blocks/counting.html">Counting</a> section
later.</p>
</blockquote>
<p>With this, we can now modify <code>recurrence</code> to determine the necessary size of <code>mem</code>.</p>
<pre><pre class="playground"><code class="language-rust">// added:
macro_rules! count_exprs {
    () =&gt; (0);
    ($head:expr) =&gt; (1);
    ($head:expr, $($tail:expr),*) =&gt; (1 + count_exprs!($($tail),*));
}

macro_rules! recurrence {
    ( a[n]: $sty:ty = $($inits:expr),+ =&gt; $recur:expr ) =&gt; {
        {
            use std::ops::Index;

            const MEM_SIZE: usize = count_exprs!($($inits),+);
//          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ added

            struct Recurrence {
                mem: [$sty; MEM_SIZE],
//                          ^~~~~~~~ changed
                pos: usize,
            }

            struct IndexOffset&lt;'a&gt; {
                slice: &amp;'a [$sty; MEM_SIZE],
//                                ^~~~~~~~ changed
                offset: usize,
            }

            impl&lt;'a&gt; Index&lt;usize&gt; for IndexOffset&lt;'a&gt; {
                type Output = $sty;

                #[inline(always)]
                fn index&lt;'b&gt;(&amp;'b self, index: usize) -&gt; &amp;'b $sty {
                    use std::num::Wrapping;

                    let index = Wrapping(index);
                    let offset = Wrapping(self.offset);
                    let window = Wrapping(MEM_SIZE);
//                                        ^~~~~~~~ changed

                    let real_index = index - offset + window;
                    &amp;self.slice[real_index.0]
                }
            }

            impl Iterator for Recurrence {
                type Item = $sty;

                #[inline]
                fn next(&amp;mut self) -&gt; Option&lt;$sty&gt; {
                    if self.pos &lt; MEM_SIZE {
//                                ^~~~~~~~ changed
                        let next_val = self.mem[self.pos];
                        self.pos += 1;
                        Some(next_val)
                    } else {
                        let next_val = {
                            let n = self.pos;
                            let a = IndexOffset { slice: &amp;self.mem, offset: n };
                            (a[n-1] + a[n-2])
                        };

                        {
                            use std::mem::swap;

                            let mut swap_tmp = next_val;
                            for i in (0..MEM_SIZE).rev() {
//                                       ^~~~~~~~ changed
                                swap(&amp;mut swap_tmp, &amp;mut self.mem[i]);
                            }
                        }

                        self.pos += 1;
                        Some(next_val)
                    }
                }
            }

            Recurrence { mem: [$($inits),+], pos: 0 }
        }
    };
}
/* ... */
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let fib = recurrence![a[n]: u64 = 0, 1 =&gt; a[n-1] + a[n-2]];
</span><span class="boring">
</span><span class="boring">    for e in fib.take(10) { println!(&quot;{}&quot;, e) }
</span><span class="boring">}
</span></code></pre></pre>
<p>With that done, we can now substitute the last thing: the <code>recur</code> expression.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">macro_rules! count_exprs {
</span><span class="boring">    () =&gt; (0);
</span><span class="boring">    ($head:expr $(, $tail:expr)*) =&gt; (1 + count_exprs!($($tail),*));
</span><span class="boring">}
</span><span class="boring">macro_rules! recurrence {
</span><span class="boring">    ( a[n]: $sty:ty = $($inits:expr),+ =&gt; $recur:expr ) =&gt; {
</span><span class="boring">        {
</span><span class="boring">            use std::ops::Index;
</span><span class="boring">
</span><span class="boring">            const MEM_SIZE: usize = count_exprs!($($inits),+);
</span><span class="boring">            struct Recurrence {
</span><span class="boring">                mem: [$sty; MEM_SIZE],
</span><span class="boring">                pos: usize,
</span><span class="boring">            }
</span><span class="boring">            struct IndexOffset&lt;'a&gt; {
</span><span class="boring">                slice: &amp;'a [$sty; MEM_SIZE],
</span><span class="boring">                offset: usize,
</span><span class="boring">            }
</span><span class="boring">            impl&lt;'a&gt; Index&lt;usize&gt; for IndexOffset&lt;'a&gt; {
</span><span class="boring">                type Output = $sty;
</span><span class="boring">
</span><span class="boring">                #[inline(always)]
</span><span class="boring">                fn index&lt;'b&gt;(&amp;'b self, index: usize) -&gt; &amp;'b $sty {
</span><span class="boring">                    use std::num::Wrapping;
</span><span class="boring">
</span><span class="boring">                    let index = Wrapping(index);
</span><span class="boring">                    let offset = Wrapping(self.offset);
</span><span class="boring">                    let window = Wrapping(MEM_SIZE);
</span><span class="boring">
</span><span class="boring">                    let real_index = index - offset + window;
</span><span class="boring">                    &amp;self.slice[real_index.0]
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            impl Iterator for Recurrence {
</span><span class="boring">              type Item = $sty;
</span>/* ... */
                #[inline]
                fn next(&amp;mut self) -&gt; Option&lt;u64&gt; {
                    if self.pos &lt; MEM_SIZE {
                        let next_val = self.mem[self.pos];
                        self.pos += 1;
                        Some(next_val)
                    } else {
                        let next_val = {
                            let n = self.pos;
                            let a = IndexOffset { slice: &amp;self.mem, offset: n };
                            $recur
//                          ^~~~~~ changed
                        };
                        {
                            use std::mem::swap;
                            let mut swap_tmp = next_val;
                            for i in (0..MEM_SIZE).rev() {
                                swap(&amp;mut swap_tmp, &amp;mut self.mem[i]);
                            }
                        }
                        self.pos += 1;
                        Some(next_val)
                    }
                }
/* ... */
<span class="boring">            }
</span><span class="boring">            Recurrence { mem: [$($inits),+], pos: 0 }
</span><span class="boring">        }
</span><span class="boring">    };
</span><span class="boring">}
</span><span class="boring">fn main() {
</span><span class="boring">    let fib = recurrence![a[n]: u64 = 1, 1 =&gt; a[n-1] + a[n-2]];
</span><span class="boring">    for e in fib.take(10) { println!(&quot;{}&quot;, e) }
</span><span class="boring">}
</span></code></pre></pre>
<p>And, when we compile our finished macro...</p>
<pre><code class="language-text">error[E0425]: cannot find value `a` in this scope
  --&gt; src/main.rs:68:47
   |
68 |     let fib = recurrence![a[n]: u64 = 1, 1 =&gt; a[n-1] + a[n-2]];
   |                                               ^ not found in this scope

error[E0425]: cannot find value `n` in this scope
  --&gt; src/main.rs:68:49
   |
68 |     let fib = recurrence![a[n]: u64 = 1, 1 =&gt; a[n-1] + a[n-2]];
   |                                                 ^ not found in this scope

error[E0425]: cannot find value `a` in this scope
  --&gt; src/main.rs:68:56
   |
68 |     let fib = recurrence![a[n]: u64 = 1, 1 =&gt; a[n-1] + a[n-2]];
   |                                                        ^ not found in this scope

error[E0425]: cannot find value `n` in this scope
  --&gt; src/main.rs:68:58
   |
68 |     let fib = recurrence![a[n]: u64 = 1, 1 =&gt; a[n-1] + a[n-2]];
   |                                                          ^ not found in this scope
</code></pre>
<p>... wait, what? That can't be right... let's check what the macro is expanding to.</p>
<pre><code class="language-shell">$ rustc -Z unstable-options --pretty expanded recurrence.rs
</code></pre>
<p>The <code>--pretty expanded</code> argument tells <code>rustc</code> to perform macro expansion, then turn the resulting
AST back into source code. Because this option isn't considered stable yet, we also need
<code>-Z unstable-options</code>. The output (after cleaning up some formatting) is shown below; in particular,
note the place in the code where <code>$recur</code> was substituted:</p>
<pre><code class="language-rust ignore">#![feature(no_std)]
#![no_std]
#[prelude_import]
use std::prelude::v1::*;
#[macro_use]
extern crate std as std;
fn main() {
    let fib = {
        use std::ops::Index;
        const MEM_SIZE: usize = 1 + 1;
        struct Recurrence {
            mem: [u64; MEM_SIZE],
            pos: usize,
        }
        struct IndexOffset&lt;'a&gt; {
            slice: &amp;'a [u64; MEM_SIZE],
            offset: usize,
        }
        impl &lt;'a&gt; Index&lt;usize&gt; for IndexOffset&lt;'a&gt; {
            type Output = u64;
            #[inline(always)]
            fn index&lt;'b&gt;(&amp;'b self, index: usize) -&gt; &amp;'b u64 {
                use std::num::Wrapping;
                let index = Wrapping(index);
                let offset = Wrapping(self.offset);
                let window = Wrapping(MEM_SIZE);
                let real_index = index - offset + window;
                &amp;self.slice[real_index.0]
            }
        }
        impl Iterator for Recurrence {
            type Item = u64;
            #[inline]
            fn next(&amp;mut self) -&gt; Option&lt;u64&gt; {
                if self.pos &lt; MEM_SIZE {
                    let next_val = self.mem[self.pos];
                    self.pos += 1;
                    Some(next_val)
                } else {
                    let next_val = {
                        let n = self.pos;
                        let a = IndexOffset{slice: &amp;self.mem, offset: n,};
                        a[n - 1] + a[n - 2]
                    };
                    {
                        use std::mem::swap;
                        let mut swap_tmp = next_val;
                        {
                            let result =
                                match ::std::iter::IntoIterator::into_iter((0..MEM_SIZE).rev()) {
                                    mut iter =&gt; loop {
                                        match ::std::iter::Iterator::next(&amp;mut iter) {
                                            ::std::option::Option::Some(i) =&gt; {
                                                swap(&amp;mut swap_tmp, &amp;mut self.mem[i]);
                                            }
                                            ::std::option::Option::None =&gt; break,
                                        }
                                    },
                                };
                            result
                        }
                    }
                    self.pos += 1;
                    Some(next_val)
                }
            }
        }
        Recurrence{mem: [0, 1], pos: 0,}
    };
    {
        let result =
            match ::std::iter::IntoIterator::into_iter(fib.take(10)) {
                mut iter =&gt; loop {
                    match ::std::iter::Iterator::next(&amp;mut iter) {
                        ::std::option::Option::Some(e) =&gt; {
                            ::std::io::_print(::std::fmt::Arguments::new_v1(
                                {
                                    static __STATIC_FMTSTR: &amp;'static [&amp;'static str] = &amp;[&quot;&quot;, &quot;\n&quot;];
                                    __STATIC_FMTSTR
                                },
                                &amp;match (&amp;e,) {
                                    (__arg0,) =&gt; [::std::fmt::ArgumentV1::new(__arg0, ::std::fmt::Display::fmt)],
                                }
                            ))
                        }
                        ::std::option::Option::None =&gt; break,
                    }
                },
            };
        result
    }
}
</code></pre>
<p>But that looks fine! If we add a few missing <code>#![feature(...)]</code> attributes and feed it to a nightly
build of <code>rustc</code>, it even compiles!  ... <em>what?!</em></p>
<blockquote>
<p><strong>Aside</strong>: You can't compile the above with a non-nightly build of <code>rustc</code>. This is because the
expansion of the <code>println!</code> macro depends on internal compiler details which are <em>not</em> publicly
stabilised.</p>
</blockquote>
<h3><a class="header" href="#being-hygienic" id="being-hygienic">Being Hygienic</a></h3>
<p>The issue here is that identifiers in Rust macros are <em>hygienic</em>. That is, identifiers from two
different contexts <em>cannot</em> collide. To show the difference, let's take a simpler example.</p>
<pre><code class="language-rust ignore">macro_rules! using_a {
    ($e:expr) =&gt; {
        {
            let a = 42i;
            $e
        }
    }
}

let four = using_a!(a / 10);
<span class="boring">fn main() {}
</span></code></pre>
<p>This macro simply takes an expression, then wraps it in a block with a variable <code>a</code> defined. We then
use this as a round-about way of computing <code>4</code>. There are actually <em>two</em> syntax contexts involved in
this example, but they're invisible. So, to help with this, let's give each context a different
colour. Let's start with the unexpanded code, where there is only a single context:</p>
<pre class="rust rust-example-rendered"><span class="synctx-0"><span class="macro">macro_rules</span><span class="macro">!</span> <span class="ident">using_a</span> {&#xa;    (<span class="macro-nonterminal">$</span><span class="macro-nonterminal">e</span>:<span class="ident">expr</span>) <span class="op">=&gt;</span> {&#xa;        {&#xa;            <span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="number">42</span>;&#xa;            <span class="macro-nonterminal">$</span><span class="macro-nonterminal">e</span>&#xa;        }&#xa;    }&#xa;}&#xa;&#xa;<span class="kw">let</span> <span class="ident">four</span> <span class="op">=</span> <span class="macro">using_a</span><span class="macro">!</span>(<span class="ident">a</span> <span class="op">/</span> <span class="number">10</span>);</span></pre>
<p>Now, let's expand the invocation.</p>
<pre class="rust rust-example-rendered"><span class="synctx-0"><span class="kw">let</span> <span class="ident">four</span> <span class="op">=</span> </span><span class="synctx-1">{&#xa;    <span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="number">42</span>;&#xa;    </span><span class="synctx-0"><span class="ident">a</span> <span class="op">/</span> <span class="number">10</span></span><span class="synctx-1">&#xa;}</span><span class="synctx-0">;</span></pre>
<p>As you can see, the <code><span class="synctx-1">a</span></code> that's defined by the macro is in a
different context to the <code><span class="synctx-0">a</span></code> we provided in our invocation.
As such, the compiler treats them as completely different identifiers,
<em>even though they have the same lexical appearance</em>.</p>
<p>This is something to be <em>really</em> careful of when working on macros: macros can produce ASTs which
will not compile, but which <em>will</em> compile if written out by hand, or dumped using
<code>--pretty expanded</code>.</p>
<p>The solution to this is to capture the identifier <em>with the appropriate syntax context</em>. To do that,
we need to again adjust our macro syntax. To continue with our simpler example:</p>
<pre class="rust rust-example-rendered"><span class="synctx-0"><span class="macro">macro_rules</span><span class="macro">!</span> <span class="ident">using_a</span> {&#xa;    (<span class="macro-nonterminal">$</span><span class="macro-nonterminal">a</span>:<span class="ident">ident</span>, <span class="macro-nonterminal">$</span><span class="macro-nonterminal">e</span>:<span class="ident">expr</span>) <span class="op">=&gt;</span> {&#xa;        {&#xa;            <span class="kw">let</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">a</span> <span class="op">=</span> <span class="number">42</span>;&#xa;            <span class="macro-nonterminal">$</span><span class="macro-nonterminal">e</span>&#xa;        }&#xa;    }&#xa;}&#xa;&#xa;<span class="kw">let</span> <span class="ident">four</span> <span class="op">=</span> <span class="macro">using_a</span><span class="macro">!</span>(<span class="ident">a</span>, <span class="ident">a</span> <span class="op">/</span> <span class="number">10</span>);</span></pre>
<p>This now expands to:</p>
<pre class="rust rust-example-rendered"><span class="synctx-0"><span class="kw">let</span> <span class="ident">four</span> <span class="op">=</span> </span><span class="synctx-1">{&#xa;    <span class="kw">let</span> </span><span class="synctx-0"><span class="ident">a</span></span><span class="synctx-1"> <span class="op">=</span> <span class="number">42</span>;&#xa;    </span><span class="synctx-0"><span class="ident">a</span> <span class="op">/</span> <span class="number">10</span></span><span class="synctx-1">&#xa;}</span><span class="synctx-0">;</span></pre>
<p>Now, the contexts match, and the code will compile.  We can make this adjustment to our
<code>recurrence!</code> macro by explicitly capturing <code>a</code> and <code>n</code>.  After making the necessary changes, we
have:</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! count_exprs {
    () =&gt; (0);
    ($head:expr) =&gt; (1);
    ($head:expr, $($tail:expr),*) =&gt; (1 + count_exprs!($($tail),*));
}

macro_rules! recurrence {
    ( $seq:ident [ $ind:ident ]: $sty:ty = $($inits:expr),+ =&gt; $recur:expr ) =&gt; {
//    ^~~~~~~~~~   ^~~~~~~~~~ changed
        {
            use std::ops::Index;

            const MEM_SIZE: usize = count_exprs!($($inits),+);

            struct Recurrence {
                mem: [$sty; MEM_SIZE],
                pos: usize,
            }

            struct IndexOffset&lt;'a&gt; {
                slice: &amp;'a [$sty; MEM_SIZE],
                offset: usize,
            }

            impl&lt;'a&gt; Index&lt;usize&gt; for IndexOffset&lt;'a&gt; {
                type Output = $sty;

                #[inline(always)]
                fn index&lt;'b&gt;(&amp;'b self, index: usize) -&gt; &amp;'b $sty {
                    use std::num::Wrapping;

                    let index = Wrapping(index);
                    let offset = Wrapping(self.offset);
                    let window = Wrapping(MEM_SIZE);

                    let real_index = index - offset + window;
                    &amp;self.slice[real_index.0]
                }
            }

            impl Iterator for Recurrence {
                type Item = $sty;

                #[inline]
                fn next(&amp;mut self) -&gt; Option&lt;$sty&gt; {
                    if self.pos &lt; MEM_SIZE {
                        let next_val = self.mem[self.pos];
                        self.pos += 1;
                        Some(next_val)
                    } else {
                        let next_val = {
                            let $ind = self.pos;
//                              ^~~~ changed
                            let $seq = IndexOffset { slice: &amp;self.mem, offset: $ind };
//                              ^~~~ changed
                            $recur
                        };

                        {
                            use std::mem::swap;

                            let mut swap_tmp = next_val;
                            for i in (0..MEM_SIZE).rev() {
                                swap(&amp;mut swap_tmp, &amp;mut self.mem[i]);
                            }
                        }

                        self.pos += 1;
                        Some(next_val)
                    }
                }
            }

            Recurrence { mem: [$($inits),+], pos: 0 }
        }
    };
}

fn main() {
    let fib = recurrence![a[n]: u64 = 0, 1 =&gt; a[n-1] + a[n-2]];

    for e in fib.take(10) { println!(&quot;{}&quot;, e) }
}
</code></pre></pre>
<p>And it compiles!  Now, let's try with a different sequence.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">macro_rules! count_exprs {
</span><span class="boring">    () =&gt; (0);
</span><span class="boring">    ($head:expr) =&gt; (1);
</span><span class="boring">    ($head:expr, $($tail:expr),*) =&gt; (1 + count_exprs!($($tail),*));
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">macro_rules! recurrence {
</span><span class="boring">    ( $seq:ident [ $ind:ident ]: $sty:ty = $($inits:expr),+ =&gt; $recur:expr ) =&gt; {
</span><span class="boring">        {
</span><span class="boring">            use std::ops::Index;
</span><span class="boring">            
</span><span class="boring">            const MEM_SIZE: usize = count_exprs!($($inits),+);
</span><span class="boring">    
</span><span class="boring">            struct Recurrence {
</span><span class="boring">                mem: [$sty; MEM_SIZE],
</span><span class="boring">                pos: usize,
</span><span class="boring">            }
</span><span class="boring">    
</span><span class="boring">            struct IndexOffset&lt;'a&gt; {
</span><span class="boring">                slice: &amp;'a [$sty; MEM_SIZE],
</span><span class="boring">                offset: usize,
</span><span class="boring">            }
</span><span class="boring">    
</span><span class="boring">            impl&lt;'a&gt; Index&lt;usize&gt; for IndexOffset&lt;'a&gt; {
</span><span class="boring">                type Output = $sty;
</span><span class="boring">    
</span><span class="boring">                #[inline(always)]
</span><span class="boring">                fn index&lt;'b&gt;(&amp;'b self, index: usize) -&gt; &amp;'b $sty {
</span><span class="boring">                    use std::num::Wrapping;
</span><span class="boring">                    
</span><span class="boring">                    let index = Wrapping(index);
</span><span class="boring">                    let offset = Wrapping(self.offset);
</span><span class="boring">                    let window = Wrapping(MEM_SIZE);
</span><span class="boring">                    
</span><span class="boring">                    let real_index = index - offset + window;
</span><span class="boring">                    &amp;self.slice[real_index.0]
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">    
</span><span class="boring">            impl Iterator for Recurrence {
</span><span class="boring">                type Item = $sty;
</span><span class="boring">    
</span><span class="boring">                #[inline]
</span><span class="boring">                fn next(&amp;mut self) -&gt; Option&lt;$sty&gt; {
</span><span class="boring">                    if self.pos &lt; MEM_SIZE {
</span><span class="boring">                        let next_val = self.mem[self.pos];
</span><span class="boring">                        self.pos += 1;
</span><span class="boring">                        Some(next_val)
</span><span class="boring">                    } else {
</span><span class="boring">                        let next_val = {
</span><span class="boring">                            let $ind = self.pos;
</span><span class="boring">                            let $seq = IndexOffset { slice: &amp;self.mem, offset: $ind };
</span><span class="boring">                            $recur
</span><span class="boring">                        };
</span><span class="boring">    
</span><span class="boring">                        {
</span><span class="boring">                            use std::mem::swap;
</span><span class="boring">    
</span><span class="boring">                            let mut swap_tmp = next_val;
</span><span class="boring">                            for i in (0..MEM_SIZE).rev() {
</span><span class="boring">                                swap(&amp;mut swap_tmp, &amp;mut self.mem[i]);
</span><span class="boring">                            }
</span><span class="boring">                        }
</span><span class="boring">    
</span><span class="boring">                        self.pos += 1;
</span><span class="boring">                        Some(next_val)
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">    
</span><span class="boring">            Recurrence { mem: [$($inits),+], pos: 0 }
</span><span class="boring">        }
</span><span class="boring">    };
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>for e in recurrence!(f[i]: f64 = 1.0 =&gt; f[i-1] * i as f64).take(10) {
    println!(&quot;{}&quot;, e)
}
<span class="boring">}
</span></code></pre></pre>
<p>Which gives us:</p>
<pre><code class="language-text">1
1
2
6
24
120
720
5040
40320
362880
</code></pre>
<p>Success!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="macros/minutiae/import-export.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="patterns.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="macros/minutiae/import-export.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="patterns.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
